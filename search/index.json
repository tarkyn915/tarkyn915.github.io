[{"content":"Nginx官网\n基础模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 server { listen 80; listen 443 ssl http2; listen [::]:80; listen [::]:443 ssl http2; root /var/www/html; index index index.html index.htm; server_name xxx.xxx; ssl_certificate /root/xxx.xxx.crt; ssl_certificate_key /root/xxx.xxx.key; location / { try_files $uri $uri/ =404; } } 反向代理 docker容器内反代推荐使用 nginx-proxy-manager\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #内部反代 server { listen 80; server_name xxx.xxx.xxx; location / { #用于获取用户真实IP proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #将域名的请求发到8080的端口 proxy_pass http://127.0.0.1:8080; } } #外部反代 server { listen 80; server_name www.example.com; location / { proxy_pass http://example.com:80; } } server { listen 443 ssl; server_name www.example.com; ssl_certificate /etc/nginx/ssl/server.crt; ssl_certificate_key /etc/nginx/ssl/server.key; location / { proxy_pass https://example.com:443; } } 没有证书，就反代80端口\n限制上传大小 1 2 3 4 5 client_max_body_size 10m; # 设置到http{}内，控制全局nginx所有请求报文(附件)大小； # 设置到server{}内，控制该server的所有请求报文(附件)大小； # 设置到location{}内，只控制满足该路由规则的请求报文(附件)大小。 ","date":"2023-12-15T00:00:00Z","permalink":"https://blog.tjq.one/p/nginx-config/","title":"Nginx config"},{"content":"ssl优化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #ssl协议相关 ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; #ssl缓存优化 ssl_session_cache shared:SSL:10m; ssl_session_timeout 10m; # 指定TLS协议版本 1.2和1.3 # 定义加密套件和算法 # 服务器加密套件优先级 # SSL会话缓存类型和大小 # SSL会话缓存储存时间 ","date":"2023-12-15T00:00:00Z","permalink":"https://blog.tjq.one/p/nginx-optimize/","title":"Nginx optimize"},{"content":"框架 Hugo官网 Hugo中文文档\n主题 Anubis\nHugo博客搭建我把它分为两大块 Hugo部署 和 主题配置\nHugo部署 Windows下部署Hugo非常简单\n下载 win-amd64 拓展版，解压出来把hugo.exe放在一个你想放在的地方\n把这个目录添加到系统的环境变量中 Path\n官方推荐使用 PowerShell ，如果安装正确 输入 hugo version 会输出hugo的版本信息，其实如不直接用 VS code\n1 2 3 4 5 6 7 8 # 选择一个目录，创建一个新的网站 hugo new site blogxxxx # 创建一个新的文章 hugo new posts/test.md # 最后启动服务器 hugo server 在浏览器中访问 http://localhost:1313\n主题配置 在github上找到你喜欢的主题，直接下载zip包解压放入themes文件夹中，然后在配置文件中改一下主题名字即可，根据主题的配置方法进行配置\n备份根目录默认配置文件hugo.toml → hugobackup.toml，然后新建一个 config.yaml 进行编辑\nstack主题\n使用说明\n","date":"2023-12-05T00:00:00Z","permalink":"https://blog.tjq.one/p/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","title":"Hugo 博客搭建"},{"content":"1.黑客帝国 一个全屏的数字雨，可以用来装高手\n1 2 apt install cmatrix cmatrix 2.艺术字生成 toilet 1 apt install toilet 1 2 3 4 5 toilet TJQ # 双色字 toilet -f mono12 -F metal TJQ # 彩虹字 toilet -f mono12 -F TJQ 4.yes命令 1 yes TJQ 会无穷无尽的输出\n5.查看系统信息 三个效果都差不多\n1 apt install screenfetch 1 apt install linuxlogo 1 apt install neofetch ","date":"2023-03-28T00:00:00Z","permalink":"https://blog.tjq.one/p/%E6%9C%89%E8%B6%A3%E7%9A%84-linux/","title":"有趣的 Linux"},{"content":"Docker 安装 脚本自动安装，并设置开机自启\n1 2 3 4 5 6 7 8 9 # 国际鸡 curl -fsSL https://get.docker.com | bash -s docker # 国内鸡 bash \u0026lt;(curl -sSL https://linuxmirrors.cn/docker.sh) # docker-compose安装 apt install docker-compose -y systemctl start docker systemctl enable docker Docker常用指令 查看所有容器\n1 docker ps -a 查看所有镜像\n1 docker image ls -a 启动停止删除容器\n1 2 3 4 docker start ID docker stop ID docker kill ID docker rm ID ","date":"2023-03-19T00:00:00Z","permalink":"https://blog.tjq.one/p/docker-%E5%AE%89%E8%A3%85/","title":"Docker 安装"},{"content":"搭建环境 在电脑中安装 nodejs git 这两个软件\n1 2 3 node -v npm -v git -v 检查完毕后开始全局安装hexo\n1 2 npm install hexo-cli -g hexo -v 然后在文件夹中生成博客文件,有笔记的可以直接放到post文件夹中\n1 hexo init 之后主题，样式自行修改，部署配置在博客根目录下的config文件\n1 2 3 4 deploy: type: \u0026#39;git\u0026#39; repo: https://github.com/xxxxxx/xxxxx.github.io.git branch: master hexo常用的命令\n1 2 3 4 5 6 7 8 # 本地预览 hexo s # 清除本地文件 hexo clear # 生成静态文件 hexo g # 部署到指定目录 hexo d 运行hexo指令时出现 ERROR Deployer not found: git 是因为少了hexo对git的deploy组件\nnpm install \u0026ndash;save hexo-deployer-git\n博客迁移 博客迁移记得保存好自己的文章，别的其实不重要，文章不能丢失，最好就是保存一下 config 配置文件\n转移数据 可以保存一下的，文章是最重要的，别的不保存也没事 _config.yml：站点配置文件 source：自己写的博客文件 themes：主题\n一些特殊情况 git config --global --add safe.directory \u0026quot;*\u0026quot; 手动禁用安全目录\n上传到GitHub域名失效，可以在source文件夹里新建一个文件 CNAME 里面写上域名\n一些自定义效果 博客字体 新建一个css样式表，然后导入即可，代码如下。\n1 2 3 4 5 6 7 8 9 10 11 12 @font-face{ font-family: \u0026#39;HarmonyOS\u0026#39; src: local(\u0026#39;HarmonyOS\u0026#39;), url(\u0026#39;https://npm.elemecdn.com/zkeq-font@1.0.0/HarmonyOS.ttf\u0026#39;) format(\u0026#39;truetype\u0026#39;); font-display: swap; font-weight: bold; font-style: normal; } body{ font-family: HarmonyOS } 鼠标样式 先去准备一个鼠标样式，比如我这个钻石剑和钻石镐，然后自己创建一个css把以下代码复制进去，然后把自己创建的css在主题的index.styl中导入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 body { cursor: url(../img/mouse/1.png), auto; } .hide-block\u0026gt;.hide-button.open, .hide-inline\u0026gt;.hide-button.open { display: block } a, button, img { cursor: url(../img/mouse/2.png), auto } ","date":"2023-03-15T00:00:00Z","permalink":"https://blog.tjq.one/p/hexo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","title":"Hexo 博客搭建"},{"content":"一些linux的基础设置，根据个人需求修改\n修改SSH默认端口 22 为 SSH 默认端口，如果不放心就换个端口\nSSH 配置文件目录 /etc/ssh/sshd_config ，打开修改 #Port 22 修改成Port **\n重启SSH服务 service sshd restart\n重启SSH服务systemctl restart sshd.service\n不同发行版重启SSH服务方法不同，第二种基本通用\n检查SSH端口是否正常被监听netstat -tlpna，没有的话需要安装这个工具\n建议从 1024 - 65535 选择端口修改，有防火墙的话，记得在防火墙中开启相应的端口，不然就\u0026hellip;\n修改系统主机名 查看系统的主机名\n1 2 3 4 5 6 7 8 9 10 11 # 默认查看方式 hostname # 系统指令 hostnamectl # 最简单方便 uname -a # 主机名文件目录 /etc/hostname 修改系统主机名\n1 2 3 4 5 # 直接修改这个文件 /etc/hostname # 指令直接修改，可以用 -h 查看更多设置 hostnamectl set-hostname ### 禁止Ping 禁止Ping有两个因素，内核参数和防火墙，有一个禁止就无法ping了\n关闭ICMP协议来达到禁止Ping的效果\n1 2 3 4 5 6 7 8 # 在配置文件最后添加 /etc/sysctl.conf net.ipv4.icmp_echo_ignore_all=1 # 重新加载配置文件 sysctl -p # 快速用法 echo net.ipv4.icmp_echo_ignore_all=1 \u0026gt;\u0026gt; /etc/sysctl.conf 0表示允许,1表示禁止\n通过防火墙设置\n1 2 3 4 5 6 7 8 9 10 # iptables防火墙设置 iptables -A INPUT -p icmp --icmp-type echo-request -j DROP iptables -A OUTPUT -p icmp --icmp-type echo-reply -j DROP # -A是添加，想要删除用-D就可以了 # Ufw防火墙设置 /etc/ufw/before.rules ok icmp codes for INPUT ok icmp code for FORWARD 自行修改icmp配置就可以了 更换镜像源 备份官方源 /etc/apt/sources.list\n1 cp /etc/apt/sources.list /etc/apt/sources.list_backup 打开 sources.list 修改，删除之前的源，添加相应的源\n清华大学\n浙江大学\n更换好了之后进行 apt update -y\n","date":"2023-03-15T00:00:00Z","permalink":"https://blog.tjq.one/p/linux-%E5%9F%BA%E7%A1%80%E8%AE%BE%E7%BD%AE/","title":"Linux 基础设置"},{"content":"Linux系统目录结构 使用 ls / 就可以看到根目录 Linux系统中一切皆文件 swap分区是交换分区类似虚拟内存 目录 解释 /bin Binaries(二进制文件),存放常用的命令 /sbin system Binaries 超级用户使用的比较高级的管理程序和系统守护程序 /boot 存放启动Linux时用的核心文件,包括一些连接文件和镜像文件 /dev Device(设备)存放linux的外部设备，在linux中访问设备和文件的方式是一样的(所以说一切皆文件) /etc 存放所有系统管理所需要的配置文件和子目录 /home 用户的主目录,每一个用户都有自己目录 /lib library(库)存放系统最基本的动态链接共享库,类似Windows里的DLL文件,几乎所有的应用程序都需要这些共享库 /lost+found 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件 /usr unix shared resources(共享资源),类似 windows 下的 program files 目录 /opt optional(可选)这是给主机额外安装软件所摆放的目录 /mnt 临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上然后进入该目录就可以查看光驱里的内容了 /proc Processes(进程),虚拟目录,他是系统内存的映射,访问这个目录可以获取系统信息 /run 运行目录,显示当前信息 重启就没了 /srv 该目录存放一些服务启动之后需要提取的数据 /sys 系统硬件相关的信息,该文件系统是内核设备树的一个直观反映 /tmp temporary(临时)存放一些临时文件 /var variable(变量)存放一些经常改变的东西,包括各种日志文件 VI/VIM编辑器 vi是Unix系统中最通用的文本编辑器 vim编辑器是从vi中发展出来的更强大的文本编辑器,可以主动以字体颜色辨别语法正确性,vim和vi编辑器完全兼容.\nvim编辑器中有三种模式 i进入编辑模式 :进入命令模式 :wq 保存写入 U(undo)可以回退之前的操作 Esc回到一般模式\n一般模式 指令 解释 yy 复制一行 p 粘贴 dd 删除一行 dw 删除一个单词 e 踏前斩(建议自己试一试) b 回城(建议自己试一试) gg 头 shift+g 尾 编辑模式 指令 解释 i 当前光标前 a 当前光标后 o 当前光标下一行 I 光标所在行最前 A 光标所在行最后 O 当前光标行的上一行 命令模式 指令 解释 :set nu 打开行号 :set nonu 关闭行号 :w 保存 :q 退出 :wq 保存并退出 :q! 不保存强制退出 /abc 查找abc n向下 N向上 :s/old/new 替换当前行匹配到的第一个old为new :%s/old/new 替换当前文档每一行匹配到的第一个old为new :%s/old/new/g 替换当前文档中所有的old为new 以上选取了个人觉得常用方便的指令,并不是所有指令\nLinux网络配置 ifconfig 查看Linux ip信息\n修改linux 网卡配置文件 网卡配置文件存放在 /etc/sysconfig/network-scripts/ifcfg-ens33 修改配置文件后，需要重启网络服务：systemctl restart network\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 TYPE=\u0026#34;Ethernet\u0026#34; #网卡类型 Ethernet以太网 PROXY_METHOD=\u0026#34;none\u0026#34; BROWSER_ONLY=\u0026#34;no\u0026#34; BOOTPROTO=\u0026#34;static\u0026#34; #网络配置方式 static为静态 DHCP为动态 DEFROUTE=\u0026#34;yes\u0026#34; IPV4_FAILURE_FATAL=\u0026#34;no\u0026#34; IPV6INIT=\u0026#34;yes\u0026#34; IPV6_AUTOCONF=\u0026#34;yes\u0026#34; IPV6_DEFROUTE=\u0026#34;yes\u0026#34; IPV6_FAILURE_FATAL=\u0026#34;no\u0026#34; IPV6_ADDR_GEN_MODE=\u0026#34;stable-privacy\u0026#34; NAME=\u0026#34;ens33\u0026#34; #网络接口名称 UUID=\u0026#34;484acc59-d7e7-43a3-a4a8-3efa02603bca\u0026#34; #网卡地址 DEVICE=\u0026#34;ens33\u0026#34; #网络设备名称 ONBOOT=\u0026#34;yes\u0026#34; #是否开机自动启动 IPADDR=192.168.254.100 #IP地址 GATEWAY=192.168.254.2 #网关 DNS1=192.168.254.2 #域名解析服务器 NETMASK=255.255.255.0 #子网掩码 一般是修改了网络配置方式之后，需要自行添加下面的ip地址，网关，dns等.. CentOS 7系统管理 基本语法 systemctl start | stop | restart | status 服务名\n查看服务的方法 /usr/lib/systemd/system\n系统服务开机自启 setup\n系统运行级别 开机 \u0026ndash; BIOS \u0026ndash; /boot \u0026ndash; init进程 \u0026ndash; 运行级别 \u0026ndash; 运行级对应的服务\nLinux系统有7个运行模式 常用的级别是3和5\n运行级别0: 系统停机状态，系统默认不能设置0 否则不能正常启动 运行级别1: 单用户工作状态，root权限，用于系统维护，禁止远程登陆 类似Windows的安全模式 运行级别2: 多用户状态(没有NFS)，不支持网络 运行级别3: 完全的多用户状态(有NFS)，登陆后进入控制台命令行模式 运行级别4: 系统保留，未使用 运行级别5: X11控制台，登录后进入图形GUI模式 运行级别6: 系统正常关闭并重启，默认运行级别不能设6 否则不能正常启动 systemctl get-default 查看当前运行级别\nvi /etc/inittab 查看默认级别\nCtrl + Alt+ ? 快捷键\ninit ? ?对应系统级别的数字\nCentOS 7配置开机自启动 查看所有开机自启动的信息 systemctl list-unit-files\n设置开机是否自启动 systemctl disable/enable xxxxxxxx\n","date":"2022-12-06T00:00:00Z","permalink":"https://blog.tjq.one/p/linux-%E5%9F%BA%E7%A1%80/","title":"Linux 基础"},{"content":"安装方法 官方文档 查看官方文档可以解决%99的问题\n需要注意的是，官方文档是这样写的，但是无法正常回调\n1 2 3 Homepage URL - 填写面板的访问域名，如：http://cdn.example.com:8008 Authorization callback URL - 填写回调地址，如：http://cdn.example.com/oauth2/callback:8008 回调地址应该这样设置，把端口写在前面\n1 http://cdn.example.com:8008/oauth2/callback 官网可能已经更新写法，按照官网就行，更新于2023-12-06\n反向代理 域名解析加上vps.xxx.xxx , 上面的地址填写 vps.xxx.xxx:8008 （在nginx配置文件中添加一个server，方便与80网页共存）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 server { listen 80; proxy_set_header X-Real-IP $remote_addr; server_name vps.xxx.xxx; location / { proxy_pass http://127.0.0.1:8008; proxy_set_header Host $http_host; proxy_set_header Upgrade $http_upgrade; } location ~ ^/(ws|terminal/.+)$ { proxy_pass http://127.0.0.1:8008; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026#34;Upgrade\u0026#34;; proxy_set_header Host $http_host; } } 这个反向代理参数必须用哪吒教程里给的，不然获取不到服务器数据\n美化插件 首先确定哪吒面板搭建正常，替换文件数据默认是英文的 info 和 Down\u0026amp;Up 可以自行进去修改\n找到docker目录替换文件，然后替换template这个文件夹即可\n1 /var/lib/docker/overlay2/随机的目录/merged/dashboard/resource/template 自用主题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 \u0026lt;style\u0026gt; /* 屏幕适配 */ @media only screen and (min-width: 1200px) { .ui.container { width: 80% !important; } } @media only screen and (max-width: 767px) { .ui.card\u0026gt;.content\u0026gt;.header:not(.ui), .ui.cards\u0026gt;.card\u0026gt;.content\u0026gt;.header:not(.ui) { margin-top: 0.4em !important; } } /* 整体图标 */ i.icon { color: #000; width: 1em !important; } /* 背景图片 */ body { content: \u0026#34; \u0026#34; !important; background: fixed !important; z-index: -1 !important; top: 0 !important; right: 0 !important; bottom: 0 !important; left: 0 !important; background-position: top !important; background-repeat: no-repeat !important; background-size: cover !important; background-image: url(https://gitee.com/darki/img/raw/master/1631081013043.webp) !important; font-family: Arial,Helvetica,sans-serif !important; } /* 进度条 */ .ui.progress { border-radius: 0.5rem !important; } .ui.progress .bar { min-width: 1.8em !important; border-radius: 0.5rem !important; line-height: 1.65em !important; } .ui.fine.progress\u0026gt; .bar { } .ui.progress\u0026gt; .bar { } .ui.progress.fine .bar { } .ui.progress.warning .bar { } .ui.progress.error .bar { } .ui.progress.offline .bar { } /* 导航栏 */ .ui.large.menu { border: 0 !important; border-radius: 0rem !important; background-color: rgba(255, 255, 255, 55%) !important; } /* 首页按钮 */ .ui.menu .active.item { background-color: transparent !important; } /* 导航栏下拉框 */ .ui.dropdown .menu { border: 0 !important; border-radius: 1rem !important; background-color: rgba(255, 255, 255, 80%) !important; } /* 登陆按钮 */ .nezha-primary-btn { background-color: transparent !important; color: #000 !important; } /* 大卡片 */ #app .ui.fluid.accordion { background-color: #fbfbfb26 !important; border-radius: 1rem !important; } /* 小卡片 */ .ui.four.cards\u0026gt;.card { background-color: #fafafaa3 !important; border-radius: 1rem !important; } .status.cards .wide.column { padding-top: 0 !important; padding-bottom: 0 !important; } .status.cards .three.wide.column { } .status.cards .wide.column:nth-child(1) { } .status.cards .wide.column:nth-child(2) { } .status.cards .description { } /* 小鸡名 */ .status.cards .flag { margin-right: 0.5rem !important; } /* 上传下载 */ .status.cards .outline.icon { margin-right: 1px !important; } i.arrow.alternate.circle.down.outline.icon { color: #21ba45 !important; } i.arrow.alternate.circle.up.outline.icon { color: red !important; } /* 弹出卡片小箭头 */ .ui.right.center.popup { margin: -3px 0 0 0.914286em !important; -webkit-transform-origin: left 50% !important; transform-origin: left 50% !important; } .ui.bottom.left.popup { margin-left: 1px !important; margin-top: 3px !important; } .ui.top.left.popup { margin-left: 0 !important; margin-bottom: 10px !important; } .ui.top.right.popup { margin-right: 0 !important; margin-bottom: 8px !important; } .ui.left.center.popup { margin: -3px .91428571em 0 0 !important; -webkit-transform-origin: right 50% !important; transform-origin: right 50% !important; } .ui.right.center.popup:before, .ui.left.center.popup:before { border: 0px solid #fafafaeb !important; background: #fafafaeb !important; } .ui.top.popup:before { border-color: #fafafaeb transparent transparent !important; } .ui.popup:before { border-color: #fafafaeb transparent transparent !important; } .ui.bottom.left.popup:before { border-radius: 0 !important; border: 1px solid transparent !important; border-color: #fafafaeb transparent transparent !important; background: #fafafaeb !important; -webkit-box-shadow: 0px 0px 0 0 #fafafaeb !important; box-shadow: 0px 0px 0 0 #fafafaeb !important; -webkit-tap-highlight-color: rgba(0,0,0,0) !important; } .ui.bottom.right.popup:before { border-radius: 0 !important; border: 1px solid transparent !important; border-color: #fafafaeb transparent transparent !important; background: #fafafaeb !important -webkit-box-shadow: 0px 0px 0 0 #fafafaeb !important; box-shadow: 0px 0px 0 0 #fafafaeb !important; -webkit-tap-highlight-color: rgba(0,0,0,0) !important; } .ui.top.left.popup:before { border-radius: 0 !important; border: 1px solid transparent !important; border-color: #fafafaeb transparent transparent !important; background: #fafafaeb !important; -webkit-box-shadow: 0px 0px 0 0 #fafafaeb !important; box-shadow: 0px 0px 0 0 #fafafaeb !important; -webkit-tap-highlight-color: rgba(0,0,0,0) !important; } .ui.top.right.popup:before { border-radius: 0 !important; border: 1px solid transparent !important; border-color: #fafafaeb transparent transparent !important; background: #fafafaeb !important; -webkit-box-shadow: 0px 0px 0 0 #fafafaeb !important; box-shadow: 0px 0px 0 0 #fafafaeb !important; -webkit-tap-highlight-color: rgba(0,0,0,0) !important; } .ui.left.center.popup:before { border-radius: 0 !important; border: 1px solid transparent !important; border-color: #fafafaeb transparent transparent !important; background: #fafafaeb !important; -webkit-box-shadow: 0px 0px 0 0 #fafafaeb !important; box-shadow: 0px 0px 0 0 #fafafaeb !important; -webkit-tap-highlight-color: rgba(0,0,0,0) !important; } /* 弹出卡片 */ .status.cards .ui.content.popup { min-width: 20rem !important; line-height: 2rem !important; border-radius: 1rem !important; border: 1px solid transparent !important; background-color: #fafafaeb !important; font-family: Arial,Helvetica,sans-serif !important; } .ui.content { margin: 0 !important; padding: 1em !important; } /* 服务页 */ .ui.table { background: RGB(225,225,225,0.6) !important; border-radius: 1rem !important; } .ui.table thead th { background: transparent !important; } /* 服务页进度条 */ .service-status .good { } .service-status .danger { } .service-status .warning { } /* 版权 */ .ui.inverted.segment, .ui.primary.inverted.segment { color: #000 !important; font-weight: bold !important; background-color: #fafafaa3 !important; } \u0026lt;/style\u0026gt; \u0026lt;!--Logo和版权--\u0026gt; \u0026lt;script\u0026gt; window.onload = function(){ var avatar=document.querySelector(\u0026#34;.item img\u0026#34;) var footer=document.querySelector(\u0026#34;div.is-size-7\u0026#34;) footer.innerHTML=\u0026#34;TJQ VPS STATUS\u0026#34; footer.style.visibility=\u0026#34;visible\u0026#34; avatar.style.visibility=\u0026#34;visible\u0026#34; } \u0026lt;/script\u0026gt; ","date":"2022-11-28T00:00:00Z","permalink":"https://blog.tjq.one/p/%E5%93%AA%E5%90%92%E9%9D%A2%E6%9D%BF%E6%90%AD%E5%BB%BA/","title":"哪吒面板搭建"},{"content":"安装青龙面板 安装Docker，国内机用国内镜像\n1 curl -fsSL https://get.docker.com | bash -s docker 启动 Docker，并设置 Docker 开机自动启动\n1 2 sudo systemctl start docker sudo systemctl enable docker 拉取Docker hub中的青龙镜像 链接\n1 docker pull whyour/qinglong:latest 然后部署青龙面板\n1 2 3 4 5 6 7 8 9 docker run -dit \\ -v $PWD/ql/config:/ql/config \\ -v $PWD/ql/log:/ql/log \\ -v $PWD/ql/db:/ql/db \\ -p 5600:5600 \\ --name qinglong \\ --hostname qinglong \\ --restart always \\ whyour/qinglong:latest 初始化青龙面板 访问默认端口5600，进行一些基础设置\n如果开启了防火墙，记得开启相应端口\nJD脚本 首先要获取JD的cookie\n移动版JD 使用 Chrome 内核浏览器，打开开发者模式（快捷键：F12），打开 Network（网络）标签，搜索 pt_key 里面找到 pt_key=XXXXX; pt_pin=XXXXX; 复制到环境变量中\n之后要做的事情就是去找各大脚本\n依赖 NodeJs 依赖库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 crypto-js prettytable dotenv jsdom date-fns tough-cookie tslib ws@7.4.3 ts-md5 jsdom -g jieba fs form-data json5 global-agent png-js @types/node require typescript js-base64 axios moment ds Python3 依赖库 1 2 3 4 5 requests canvas ping3 jieba aiohttp Linux 依赖库 1 2 3 bizCode bizMsg lxml ","date":"2022-11-28T00:00:00Z","permalink":"https://blog.tjq.one/p/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E6%90%AD%E5%BB%BA/","title":"青龙面板搭建"},{"content":"私聊BotFather创建机器人 查找 BotFather 以获得 api。\nBotFather 是 Telegram 官方的机器人，用于创建新机器人账户和管理自己已存在的机器人。\n点击开始，发送 /newbot，为你的机器人取一个名字，并将其发送给 BotFather。\n为你的机器人创建用户名，用户名必须以 bot 结尾，例如 telegeam_bot 或者 telegramBot。其后 BotFather 会发送一条包含这个机器人 API 的消息，记下 API 下面会用到。（不要把 token 发送给其他人，因为其他人可以通过 token 控制你的机器人）。\nps：如果不小心退出，或者忘记了这个机器人的 API，你仍然可以发送 /mybots ,选择你刚刚创建的机器人，查看 API Token\n私聊Livegram Bot绑定机器人 Livegram Bot 可以用于创建电报转发机器人，它可以将发送给机器人的消息转发给你。\n查找 Livegram Bot，并点击开始\n发送 /addbot\n把从 BotFather 获取到的机器人 API 发送给 Livegram Bot\n到这基本上就设置的差不多了,后续可以给机器人改头像，描述等\n","date":"2022-11-18T00:00:00Z","permalink":"https://blog.tjq.one/p/telegram-%E7%A7%81%E8%81%8A%E6%9C%BA%E5%99%A8%E4%BA%BA/","title":"Telegram 私聊机器人"},{"content":"Git对比SVN SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己的代码推送到中央服务器。集中式版本控制系统是必须联网才能工作。\nGit是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上，可以离线工作。\nGit常用命令 设置用户签名 签名用来识别用户，以便区分不同的开发人员。\n1 2 git config --global user.email \u0026#34;taojinqi666@163.com\u0026#34; git config --global user.name \u0026#34;tarkyn915\u0026#34; 初始化本地库\nCD到一个文件夹下面，或者用 git bash here 文件夹中出现一个隐藏的 .git 文件夹时就说明所有的文件夹已经被git管理了。\n1 2 # git 初始化的指令 $ git init Git工作区.暂存区.版本库 .git目录不属于工作区，他是一个版本库，当代码提交到master中就会有一个记录了。\rgit add 我们要放入暂存区，要使用 git add 指令\n把单独一个文件放在暂存区\n1 2 # 把文件夹下的 index.txt 文本放在暂存区 $ git add index.txt 把单独一个文件夹放在暂存区（暂存区不能存放空文件夹）\n1 2 # 把文件夹下的 XXXX文件夹 放在暂存区 $ git add XXXX/ 把所有文件都放在暂存区\n1 2 3 4 5 # 把文件夹下所有的内容都放在暂存区 $ git add --all # git add --all 有一个简单的写法 $ git add . 全部存放的时候使用上面两个指令哪个都行\ngit status 显示工作目录和暂存区状态\ngit commit 1 2 # 把暂存区的内容放到版本库中 $ git commit -m \u0026#34;第一个版本\u0026#34; 1 2 3 # 查看当前历史区版本信息 $ git log 查看目前版本信息 $ git relog 查看过去所有的历史记录 git reset 与 git revert git reset 是回滚到对应的commit-id，相当于是删除了commit-id以后的所有的提交，并且不会产生新的commit-id记录，如果要推送到远程服务器的话，需要强制推送-f\ngit revert 是反做撤销其中的commit-id，然后重新生成一个commit-id。不会对其他的提交commit-id产生影响，如果要推送到远程服务器的话，就是普通的操作git push就好了\n1 2 3 4 5 6 7 8 9 # 回退到上一次提交的版本 $ git reset --hard HEAD^ # 回退到上上次提交的版本 $ git reset --hard HEAD^^ $ git reset --hard HEAD~2 # 回退上一个版本到暂存区，不会回退到工作区 $ git reset --soft HEAD^ 1 2 3 4 # 撤销当前版本，但不会删除这个版本，会生成一个新的版本 $ git revert HEAD # 会撤销两个版本，当前一个版本，然后^又是一个版本[注意和reset是有区别的] $ git revert HEAD^ Git分支 1 2 # 创建一个dev分支(名字可以随意) $ git branch dev 1 2 # 查看当前分支情况 $ git branch 会看到，当前有两个分支了 一个是 master，一个是 dev 前面有个 * 号，并且有高亮显示的，表示你当前所处的分支 1 2 # 切换到 dev 分支 $ git checkout dev 合并分支 git 的合并分支，只能是把别的分支的内容合并到自己的分支上\n使用的指令是 git merge\n1 2 3 4 5 # 切换到 master 分支 $ git checkout master # 把 login 的内容合并到自己的分支 $ git merge dev 这个时候，我们刚才在 dev 上开发的东西就都来到了 master 主分支上\n如果是有多个分支的话，那么所有的最后都合并到 master 分支上的时候\n主分支上就集成了所有的功能，各个分支上都是单独的页面和功能\n删除分支 合并后旧分支就没什么用了，可以删除旧分支\n使用指令 git branch -d 分支名称 来删除\n1 2 3 4 5 # 先切换到别的分支 $ git checkout master # 删除 login 分支 $ git branch -d login 远程托管仓库 在项目文件夹下打开Git bash 添加仓库地址\n1 2 $ git remote add origin *************** origin 可以随便改,目的是绑定后面的仓库链接 remote：远程的意思 add：添加的意思 origin：是一个变量名（就是指代后面一长串的地址） git remote -v 查看目前的远端地址 git remove origin 删除某个绑定变量的远端地址 git push git push会把把历史区/版本区里所有的东西上传到远端 使用 git push 指令来上传\n1 2 3 4 # 上传内容 $ git push -u origin master # 表示把内容上传到 origin 这个地址 # master 是上传到远程的 master 分支 如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。 1 2 3 4 5 6 # 第二次上传 $ git push 第二次上传因为有刚才的记录，就不用写 origin 和 master 会默认传递到 origin 这个地址的 master 分支上 除非你要传递到别的分支上 可以选择删除本地的内容，可以直接拉取远端的内容 git clone 克隆是指把远程仓库里面的内容克隆一份到本地\n可以克隆别人的 公开 的仓库，也可以克隆自己的仓库\n1 2 # 直接克隆仓库 $ git clone ************* 克隆别人的仓库，我们只能拿下来用，修改后不能从新上传\n克隆自己的仓库，我们修改后还可以再次上传更新\ngit pull 1 2 # 拉取远程最新代码 $ git pull 当代码更新以后，你想获得最新的代码,直接在项目文件夹里面使用pull指令\n这样本地仓库就和远程仓库同步了\n","date":"2022-10-01T00:00:00Z","permalink":"https://blog.tjq.one/p/git-%E5%BE%85%E6%9B%B4%E6%96%B0/","title":"Git-待更新"},{"content":"This post records some python instructions for fast search\n变量和简单的数据类型 变量 变量通常被描述为一个盒子，里面装了特定的值 在程序中可以随便修改变量的值，python始终记录变量的最新值\n1 2 3 4 5 6 7 message = \u0026#34;hello world\u0026#34; print(message) message = \u0026#34;hello python\u0026#34; print(message) --- hello world hello python 1变量名只能包含字母、数字、下划线 2变量名不能包含空格，大部分情况用下划线 3Python的关键字不能用来作为变量名字 4尽量使用简洁方便理解的名字\n字符串 字符串是Python中最常见的数据类型，用(\u0026rsquo;\u0026rsquo; \u0026quot; \u0026ldquo;)单引号or双引号来创建字符串 下面举例一些简单的字符串操作(首字母大小写，删除空白)\n1 2 3 4 5 6 7 8 9 10 name = \u0026#34;tarkyn abc\u0026#34; print(name.title()) --- Tarkyn Abc name.title() 首字母全大写 name.lower() 首字母全小写 name.rstrip() 删除左空白 name.lstrip() 删除右空白 name.strip() 剔除字符串两边空白 制表符 \\t 换行符\\n\n1 2 3 4 5 6 7 8 9 10 11 12 13 print(\u0026#34;python\u0026#34;) print(\u0026#34;\\tpython\u0026#34;) --- python python print(\u0026#34;python\u0026#34;) print(\u0026#34;\\npython\\njava\\nc\u0026#34;) --- python python java c 在字符串中使用变量\n1 2 3 4 5 6 first_name = \u0026#34;tarkyn\u0026#34; last_name = \u0026#34;abc\u0026#34; message = f\u0026#34;hello, {first_name}{last_name}\u0026#34; print(message.title()) --- Hello, Tarkynabc f是字符串format，python通过 花括号内的变量替换成字符串的格式 f是python3.6引入的，如果是之前的版本可能需要format()\nPython数字 Python数值类型通常有以下5种 ● 整型(int) 通常称为整型或整数，是正或负的整数，没有小数点 ● 长整型(long) 无限大小的整数，整数最后一个是大写或者小写的L ● 浮点型(float) 浮点型由整数部分与小数部分组成 ● 复数(complex) 复数由实数部分和虚数部分构成 ● 布尔型(bool) 布尔型是整数的子类型，布尔值有两个取值 True和False，分别对应整型的1和0\nPython中可以执行 + - * / 运算\n1 2 3 4 5 6 1/2 #传统除 1//2 #地板除 number = 100_000_000 #可以使用下划线将数字分类，清晰易读 x,y,z = 1,2,3 #可以同时给多个变量命名 列表简介 序列是Python中基本的数字结构，序列中每个元素都有一个数字表示他的位置or索引，第一个是0第二个是1 序列中开始都是0 列表是Python中常见的数据类型，和字符串一样，列表索引从0开始\n1 2 3 list = [\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;] list2 = [1, 2, 3, 4, 5] print(list[0]) 更新列表 1 2 3 4 5 6 7 8 list = [] list.append(\u0026#39;google\u0026#39;) # append()添加一个元素到列表末尾 list.append(\u0026#39;baidu\u0026#39;) list[1] = \u0026#34;Bing\u0026#34; list.insert(2,\u0026#39;yahu\u0026#39;) # insert()在列表任何位置插入新元素 print(list) --- [\u0026#39;google\u0026#39;,\u0026#39;Bing\u0026#39;,\u0026#39;yahu\u0026#39;] 删除列表 如果要从列表中删除一个元素并且不在用任何方式使用它就用del(),如果删除了元素之后还要使用那就用pop()\n1 2 3 4 5 6 7 list1 = [\u0026#39;1988\u0026#39;,\u0026#39;2000\u0026#39;,\u0026#39;2010\u0026#39;,\u0026#39;2020\u0026#39;] del list1[0] # 如果知道要删除元素在列表中的位置，可以用del() fruit = [\u0026#39;apple\u0026#39;,\u0026#39;banana\u0026#39;,\u0026#39;pear\u0026#39;] pop_fruit = fruit.pop() # pop()删除列表末尾的值，保存在另一个值中继续使用，也叫弹出 prtin(fruit) # pop()可以弹出列表中任意位置的元素，在()中指定索引即可 [\u0026#39;apple\u0026#39;,\u0026#39;banana\u0026#39;] 组织列表 Python中用sort()可以对列表进行一个排序,假设有一个汽车列表，我要进行字母排序 sort()方法永久性地修改列表元素的排序顺序，再也无法恢复原来的列表顺序\n1 2 3 4 5 cars = [\u0026#39;bmw\u0026#39;,\u0026#39;audi\u0026#39;,\u0026#39;toyota\u0026#39;,\u0026#39;subaru\u0026#39;] cars.sort() # 向sort传递参数reverse=True就会反向排序列表 print(cars) --- [\u0026#39;audi\u0026#39;,\u0026#39;bmw\u0026#39;,\u0026#39;subaru\u0026#39;,\u0026#39;toyota\u0026#39;] 要保留元素原来的排列顺序，同时用特定的顺序展示，可以用函数sorted() sorted()可以让元素按照特定顺序展示，同时不影响他们在列表中的排列顺序\n1 2 3 4 5 6 7 8 9 10 cars = [\u0026#39;bmw\u0026#39;,\u0026#39;audi\u0026#39;,\u0026#39;toyota\u0026#39;,\u0026#39;subaru\u0026#39;] print(cars) cars = [\u0026#39;bmw\u0026#39;,\u0026#39;audi\u0026#39;,\u0026#39;toyota\u0026#39;,\u0026#39;subaru\u0026#39;] #也可以向函数sorted()传递参数 reverse=True反向临时排序 print(sorted(cars)) cars = [\u0026#39;bmw\u0026#39;,\u0026#39;audi\u0026#39;,\u0026#39;toyota\u0026#39;,\u0026#39;subaru\u0026#39;] print(cars) --- [\u0026#39;bmw\u0026#39;, \u0026#39;audi\u0026#39;, \u0026#39;toyota\u0026#39;, \u0026#39;subaru\u0026#39;] [\u0026#39;audi\u0026#39;, \u0026#39;bmw\u0026#39;, \u0026#39;subaru\u0026#39;, \u0026#39;toyota\u0026#39;] [\u0026#39;bmw\u0026#39;, \u0026#39;audi\u0026#39;, \u0026#39;toyota\u0026#39;, \u0026#39;subaru\u0026#39;] 要反转列表元素的排列顺序，可以使用方法reverse()\n1 2 3 4 5 cars = [\u0026#39;bmw\u0026#39;,\u0026#39;audi\u0026#39;,\u0026#39;toyota\u0026#39;,\u0026#39;subaru\u0026#39;] cars.reverse() #注意reverse()不是按字母顺序排序，而是反转列表的顺序，也是永久性的，可以再次反转 print(cars) --- [\u0026#39;subaru\u0026#39;,\u0026#39;toyota\u0026#39;,\u0026#39;audi\u0026#39;,\u0026#39;bmw\u0026#39;] 使用函数len()可以快速知道列表的长度 len(cars) Python计算元素数量从1开始所以不会有问题\n操作列表 常常需要遍历列表的所有元素，对每个元素进行操作\nfor循环遍历列表 用for循环打印水果名单中的所有水果,这行代码从列表fruits中提取一个元素然后和fruit关联 ```python fruits = ['apple','banana','pear','orange'] for fruit in fruits: print (fruit) --- apple banana pear orange ``` 1 2 3 4 5 6 7 8 fruits = [\u0026#39;apple\u0026#39;,\u0026#39;banana\u0026#39;,\u0026#39;pear\u0026#39;,\u0026#39;orange\u0026#39;] for fruit in fruits: print (f\u0026#34;I what to eat{fruit}\u0026#34;) --- I what to eat apple I what to eat banana I what to eat pear I what to eat orange for循环需要注意缩进和冒号\n创建数值列表 1 2 3 4 5 6 7 8 list(range(6)) list(range(0,6)) list(range(0,6,2)) 列表解析 abc = [b**2 for b in range(1,11)] #用多行代码比较复杂繁琐就需要列表解析 print(abc) 数字列表简单的统计计算 1 2 3 4 digits = [1,2,3,4,5,6,7,8,9,0] min(digits) # 最小值 max(digits) # 最大值 sum(digits) # 求和 列表切片 打印列表的2、3、4个(索引就是1、2、3) 头尾减一就可以了，不会搞错\n1 2 3 fruits = [\u0026#39;apple\u0026#39;,\u0026#39;banana\u0026#39;,\u0026#39;pear\u0026#39;,\u0026#39;orange\u0026#39;] print(players[1:3]) #从索引1-3 print(players[1:3:2]) #从索引1-3每隔2个元素提取一个 默认为1 遍历切片，其实就是用for循环打印一段话加上列表的切片\n1 2 3 4 fruits = [\u0026#39;apple\u0026#39;,\u0026#39;banana\u0026#39;,\u0026#39;pear\u0026#39;,\u0026#39;orange\u0026#39;] print(\u0026#34;my favourite fruit is:\u0026#34;) for fruit in fruits[0:3]: print(fruit) 复制列表\n1 2 3 4 5 6 my_foods = [\u0026#39;pizza\u0026#39;,\u0026#39;carrot\u0026#39;,\u0026#39;cake\u0026#39;] friend_foods = my_foods[:] #只需要在复制的列表后面加一个切片并省略启示和终止索引就可以了 --- 复制列表使用切片 friend_foods = my_foods[:] 如果使用friend_foods = my_foods 就会有一个问题，这两个永远都变成一样的了，后续不能单独修改某一个列表了 元组 需要创建一系列不可修改的元素，元组可以满足这种需求，Python将不能修改的值称为~不可变的~,不可变的列表被称为元组\n1 2 3 dimensions = (200,50) for dimesion in dimensions: print(dimesion) 虽然不能修改元组的元素，但是可以给元组重新赋值 dimensions = (200,50)\ndimensions = (400,100) 相比于列表，元组是更加简单的数据结构。如果要存储一些值在生命周期内不会发生改变就可以用元组\nPython条件语句 在python中if语句可以检查当前程序的状态，并采取相应的措施\n1 2 3 4 5 6 cars = [\u0026#39;audi\u0026#39;,\u0026#39;bmw\u0026#39;,\u0026#39;toyota\u0026#39;,\u0026#39;subaru\u0026#39;] for car in cars: if car == \u0026#39;bmw\u0026#39;: print(car.upper()) else: print(car.title()) 这个案例中如果遇到是bmw就全大写，不是bmw的就首字母大写\n简单的条件测试 1 2 3 4 5 6 7 8 9 car = \u0026#39;bmw\u0026#39; #检查是否相等 car == \u0026#39;audi\u0026#39; car = \u0026#39;Audi\u0026#39; #检查是否忽略大小写 car = \u0026#39;audi\u0026#39; requested_topping = \u0026#34;mushrooms\u0026#34; #检查是否不相等 要判断两个值是否不相等，可以用(!=) if requested_topping != \u0026#39;anchovies\u0026#39;: print(\u0026#34;hello the anchovies!\u0026#34;) 数值比较 1 2 3 4 5 6 7 8 9 10 age = 19 age == 18 false age \u0026lt; 18 false age \u0026gt; 18 true 也可以比较多个条件 and必须要两个条件都满足，or只需要一个条件满足就可以了 age_0 = 20 age_1 = 21 age_0 \u0026gt; 19 and age_1 \u0026gt; 19 #改善可读性可以把测试代码放在圆括号中(age_0 \u0026gt; 10) and (age_1 \u0026lt;= 21) age_0 \u0026gt; 19 or age_1 \u0026gt; 19 布尔式表达 布尔式通常用于记录条件，比如游戏正在运行中，是否可以编辑。\n1 2 game_active = true can_edit = false Python条件语句 Python程序语言指定非0和非空 (null)的值为true，0或者 null为false\nPython中 if 语句常见的形式\n1 2 3 4 5 age = 18 if age \u0026lt; 18: 执行语句... else age \u0026gt;=18: 执行语句... 1 2 3 4 5 6 if age \u0026lt; 18: 执行语句... elif age = 18: 执行语句... else age \u0026gt; 18: 执行语句... 1 2 3 4 5 6 7 8 if age \u0026lt; 18: 执行语句... elif age == 25: 执行语句... elif age \u0026gt;25\u0026lt;45: 执行语句... elif：age \u0026gt;=65: 执行语句... Python 字典 字典是另一种可变容器模型，且可以储存任意类型对象\n字典的每个键值key：value 用：分割，整个字典包括在花括号{}中\n1 b = {key1 : value1 , key2 : value2} 键是必须不可变的，值可以取任何数据类型，数，字符串，列表，乃至字典\n1 2 dic1 = { \u0026#39;abc\u0026#39;: 123 } dic2 = {\u0026#39;abc\u0026#39;: 456 , 66 : 30 } 字典的修改更新和删除 1 2 3 4 dic1 = {\u0026#39;name\u0026#39;:\u0026#39;zhangsan\u0026#39;,\u0026#39;age\u0026#39;:18,\u0026#39;class\u0026#39;:\u0026#39;first\u0026#39; } dic1[\u0026#39;age\u0026#39;] = 19 #更新 dic1[\u0026#39;school\u0026#39;] = \u0026#39;US\u0026#39; #添加 1 2 3 4 5 dic1 = {\u0026#39;name\u0026#39;:\u0026#39;zhangsan\u0026#39;,\u0026#39;age\u0026#39;:18,\u0026#39;class\u0026#39;:\u0026#39;first\u0026#39; } del dic1[\u0026#39;name\u0026#39;] # 删除键是\u0026#39;name\u0026#39;的条目 dic1.clear() # 清空字典的所有条目 del dic1 # 删除字典 删除字典后 Print 会引发一个报错，因为del之后字典就不存在了\n如果指定的值有可能不存在可以用 get() ，如果字典中没有指定的值会返回 None\n遍历字典 用 for循环遍历字典，可申明两个变量，用于储存键和值，用 items() 返回一个键值列表\n1 2 3 4 5 6 7 favorite_languages = { \u0026#39;jen\u0026#39;: \u0026#39;python\u0026#39;, \u0026#39;zs\u0026#39;: \u0026#39;c++\u0026#39;, \u0026#39;ls\u0026#39;: \u0026#39;java\u0026#39;, } for name,language in favorite_languages.items(): print(f\u0026#34;{name} favorite language is {language}\u0026#34;) 遍历字典中所有的键用 keys() ， 遍历字典中所有的值用 values() ， 这个做法提取字典中所有的值，而没有考虑重复的问题，要提取集合中独一无二的用 set()\n1 2 3 4 5 for name in favorite_language.keys(): # keys() for language in favorite_language.values(): # values() for language in set(favorite_language.values()): # set() 字典列表嵌套 将一系列字典储存在列表中，或将列表作为值储存在字典中，称为嵌套。 其实就是套中套\n在字典中储存列表，在字典中储存字典\n1 2 3 4 5 6 for alines_number in range(30): new_alines = {\u0026#39;color\u0026#39;: \u0026#39;red\u0026#39;,\u0026#39;points\u0026#39;:\u0026#39;5\u0026#39;,\u0026#39;speed\u0026#39;:\u0026#39;10\u0026#39;} alines.append(new_alines) for alines in alines[:30]: print(alines) 1 2 3 4 computer = { \u0026#39;cpu\u0026#39;: 3500x \u0026#39;ram\u0026#39;: [\u0026#39;8g_1\u0026#39;, \u0026#39;8g_2\u0026#39;] } 1 2 3 4 5 6 7 8 9 10 11 12 users = { zhangsan:{ \u0026#39;first\u0026#39;: \u0026#39;zhang\u0026#39; \u0026#39;last\u0026#39;: \u0026#39;san\u0026#39; \u0026#39;location\u0026#39;: \u0026#39;CA\u0026#39; }, lisi:{ \u0026#39;first\u0026#39;: \u0026#39;li\u0026#39; \u0026#39;last\u0026#39;: \u0026#39;si\u0026#39; \u0026#39;location\u0026#39;: \u0026#39;JP\u0026#39; }, } 用户输入和While 循环 input函数 函数input()接受一个参数，在用input函数是要指定清楚的提示，准确的让用户输入信息\n1 2 name = input(\u0026#39;please enter your name:\u0026#39;) print(f\u0026#34;\\nhello,{name}\u0026#34;) int()获取数值输入 用input输入一个数字，python会把它当成字符串，所以要用函数int（）将数的字符串转换为数值表示\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; age = input(\u0026#34;how old are you?\u0026#34;) how old are you? 21 \u0026gt;\u0026gt;\u0026gt; age = int(age) \u0026gt;\u0026gt;\u0026gt; age \u0026gt;= 18 True 求模运算符 求模运算符%，将两个数相除并返回余数，可以用这个来判断奇数还是偶数\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; 4 % 3 1 \u0026gt;\u0026gt;\u0026gt; 6 % 3 0 \u0026gt;\u0026gt;\u0026gt; 7 % 3 1 while循环 for循环针对集合中的每个元素都执行一次，而while循环是不断运行，知道条件不满足为止\n1 2 3 4 number = 1 while number \u0026lt;= 5: print(number) number+= 1 让用户选择什么时候退出，我们可以直接在while循环中定义一个退出值，当用户输入名字之后只要没有输入quit就可以一直输入名字\n1 2 3 4 5 6 7 8 9 a = \u0026#34;你的名字是： \u0026#34; #前面创建一些个变量 b = \u0026#34;你退出了\u0026#34; cc = \u0026#34;\u0026#34; while cc !=\u0026#34;quit\u0026#34;: #while条件 只要cc不是quit就不停了 cc = input(\u0026#34;请输入你的名字：\u0026#34;) if cc !=\u0026#34;quit\u0026#34;: print(cc) #变量cc不是quit就打印刚刚输入的名字，然后回头继续执行while，因为没有结束的条件 else: print(b) #变量cc是quit了，就打印出来b了，然后while循环也停止了 使用标志，break，continue来控制循环 break立即退出循环，python循环中都可以使用break来退出循环\n1 2 3 4 5 6 7 pd = True #创建一个标志 pd 当pd为True的时候循环正常运行 while pd: message = input() if message == \u0026#39;quit\u0026#39;: #当输入的值为quit的时候，标志pd 变成False，程序就停止了 pd = False #也可以把这一行直接改成break，这样当message为quit的时候就直接退出循环 else: print(message) continue更像是弹出当前的命令从头去再次执行，并不是直接退出\n1 2 3 4 5 6 nb = 0 while nb \u0026lt;= 10: #nb小于等于10就执行while循环 nb += 1 if nb % 2 == 0: #如果nb能被2整除那就弹出从头开始，不继续下面的指令了 continue print(nb) 用while循环中处理列表和字典 for循环是一种遍历列表的有效方式，但不适合用for来修改列表，这样会让python难以跟踪里面的元素，while循环可以在遍历的同时进行修改\n1 2 3 4 5 6 7 8 unconfirmed_users = [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;] #没有验证的用户 confirmed_users = [] #创建一个验证用户的列表 while unconfirmed_users: #这里while就会去循环列表中的用户 current_users = unconfirmed_users.pop() #把循环过的用户弹出到验证用户的列表中 confirmed_users.append(current_users) #把验证列表中的用户加入到验证用户的列表中 print(confirmed_users) 用while循环去删除列表中的元素\n1 2 3 4 5 pets = [\u0026#39;cat\u0026#39;,\u0026#39;cat\u0026#39;,\u0026#39;dog\u0026#39;,\u0026#39;rabbit\u0026#39;,\u0026#39;fish\u0026#39;] print(pets) while \u0026#39;cat\u0026#39; in pets: #如果cat在这个宠物列表中 pets.remove(\u0026#39;cat\u0026#39;) #那就从这个宠物列表中移除 print(pets) 函数 定义函数 1 2 3 4 def hello(user_name): #用def告诉python我要定义一个函数 print(f\u0026#34;hello, {user_name.title()}!\u0026#34;) # ：后面的所有缩进行就变成了函数体 hello(\u0026#39;tarkyn\u0026#39;) #最后可以直接使用函数 变量username是一个形参，值tarkyn是一个实参\n设置默认值 1 2 3 4 5 def describe_pet(pet_name, animal_type=\u0026#34;dog\u0026#34;): # 编写函数时，可以给给一个形参默认值 print(f\u0026#34;my {animal_type}\u0026#39;s name is {pet_name.title()}.\u0026#34;) describe_pet(pet_name=\u0026#34;阿黄\u0026#34;) 返回值 函数并非总是直接输出，函数返回的值都称为返回值,可以用return语句将值返回到调用函数的代码行\n1 2 3 4 5 def get_name(first_name, last_name): full_name = f\u0026#34;{first_name} {last_name}\u0026#34; return full_name.title() name = get_name(\u0026#39;Jinqi\u0026#39;,\u0026#39;Tao\u0026#39;) print(name) 可选的实参 选择一个额外的选项，可以让需要的人输入\n1 2 3 4 5 6 7 8 9 def get_name(first_name, last_name, middlea_name=\u0026#39;\u0026#39;): if middlea_name: full_name = f\u0026#34;{first_name} {middlea_name} {last_name}\u0026#34; else: full_name = f\u0026#34;{first_name} {last_name}\u0026#34; return full_name.title() name = get_name(\u0026#39;Jinqi\u0026#39;,\u0026#39;Tao\u0026#39;) print(name) 返回字典 1 2 3 4 5 6 7 def build_person(first_name, last_name, age=None): person = {\u0026#39;first\u0026#39;:first_name,\u0026#39;last\u0026#39;:last_name} if age: person[\u0026#39;age\u0026#39;]=age return person a_person = build_person(\u0026#39;tao\u0026#39;,\u0026#39;jinqi\u0026#39;,age=20) print(a_person) 传递列表 1 2 3 4 5 6 7 def greet_users(names): for name in names: msg = f\u0026#34;hello, {name.title()}\u0026#34; print(msg) username = [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;] greet_users(username) 传递任意数量的实参 1 2 3 4 5 def make_pizza(size,*toppings): # 形参名 *topping 中的 * 让python创建一个topping的空元组 print(size,toppings) make_pizza(16,\u0026#39;a\u0026#39;) make_pizza(20,\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;) 1 2 3 4 5 6 7 8 9 10 def profile(first, last, **user_info): user_info[\u0026#39;first_name\u0026#39;] = first user_info[\u0026#39;last_name\u0026#39;] = last return user_info user_profile = profile(\u0026#39;tao\u0026#39;,\u0026#39;jinqi\u0026#39;, location=\u0026#39;shanghai\u0026#39;, gender= \u0026#39;male\u0026#39; ) print(user_profile) 将函数保存在模块中 pizza.py，一个单独的pizza模块\n1 2 3 import pizza # 导入这个函数模块 pizza.make_pizza(20,\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;) 1 2 3 import pizza as pz # 可以用 as 给函数指定别名 pz.make_pizza(20,\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;) 1 from pizza import pizza_1, pizza_2 # 导入模块中的特定函数 1 from pizza import * # 导入模块中的所有函数 类 ","date":"2022-08-01T00:00:00Z","permalink":"https://blog.tjq.one/p/python-%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/","title":"Python 基础笔记"}]